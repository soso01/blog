---
title: "클린코드 11장 시스템"
date: 2022-05-21
description: "클린코드 11장 시스템"
summary: "클린코드 11장 시스템"
slug: "11-system"
categories: ["study"]
tags: ["clean-code"]
---

> 복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다 - 레이 오지

### 도시를 세운다면?

- 한사람의 힘으로는 무리다. 도시에 큰 그림을 그리는 사람이 있으면 작은 사항에 집중하는 사람들도 있다.
- 도시가 돌아가는 이유는 적절한 추상화와 모듈화 때문이다.
- 큰 그림을 이해하지 못할지라도 개인과 개인이 관리하는 구성요소는 효율적으로 돌아간다.
- 소프트웨어도 도시처럼 구성한다.
  - 그런데 막상 팀이 제작하는 시스템은 비슷한 수준으로 관심사를 분리하거나 추상화를 이뤄내지 못한다.

### 시스템 제작과 시스템 사용을 분리하라

- 제작과 사용은 아주 다르다.
- 소프트웨어 시스템은 준비 과정과 런타임 로직을 분리해야 한다.
- 시작 단계는 모든 애플리케이션이 풀어야 할 관심사다.
  - 불행히도 대다수 애플리케이션은 시작 단계라는 관심사를 분리하지 않는다.
  - 준비 과정 코드를 주먹구구식으로 구현할 뿐만 아니라 런타임 로직과 마구 뒤섞는다.

```tsx
const getSercvice = () => {
	if (service === null) {
		service = new MyService(...);
	}

	return service
}
```

- 위 코드는 Lazy Initialization 이라는 기법이다.
- 장점
  - 실제로 필요할 때 까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않고, 그만큼 애플리케이션을 시작하는 시간이 빨라진다.
- 단점
  - 하지만 이 함수는 MyService 생성자 인수에 명시적으로 의존한다.
  - 런타임 로직에서 MyService 객체를 전혀 사용하지 않더라도 의존성을 해결하지 않으면 컴파일이 안된다.
  - 테스트도 문제다.
  - Myservice가 무거운 객체라면 단위테스트에서 getService를 호출하기 전에 테스트용 목 객체를 할당해야 한다.
  - 또한 일반 런타인 로직에서 객체 생성 로직을 섞어놓은 탓에 모든 실행 경로를 테스트해야 한다.
  - 무엇보다 MyService가 모든 상황에 적합한 객체인지 모른다는 사실이 가장 큰 우려다.
- 초기화 지연 기법을 한 번 정도 사용한다면 별로 심각한 문제는 아니다.
- 하지만 많은 애플리케이션이 이처럼 좀스러운 설정 기법을 수시로 사용한다.
- 그래서 전반적인 설정 방식이 애플리케이션 곳곳에 흩어진다. 모듈성은 저조하며 대개 중복이 심각하다.

- 체계적이고 탄탄한 시스템을 만들고 싶다면 흔히 쓰는 좀스럽고 손쉬운 기법으로 모듈성을 깨서는 절대 안 된다.
- 객체를 생성하거나 의존성을 연결할때도 마찬가지다.
- 설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다.
- 또한 주요 의존성을 해소하기 위한 방식, 즉 전반적이며 일관적인 방식도 필요하다.

### main 분리

- 시스템 생성과 시스템 사용을 분리하는 방법으로, 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.
- 이 방법은 제어 흐름을 따라가기 쉽다.
  - main 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘긴다.
  - 애플리케이션은 그저 객체를 사용할 뿐이다.
  - 즉, 애플리케이션은 메인이나 객체가 생성되는 과정을 전혀 모른다.
  - 단지 모든 객체가 적절히 생성되었다고 가정한다.

### 팩토리

- 물론 때로는 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다.
- 추상 팩토리 패턴 사용.
  - [https://refactoring.guru/ko/design-patterns/abstract-factory](https://refactoring.guru/ko/design-patterns/abstract-factory)
  - 객체 세트를 생성하는 패턴
  - 추상 팩토리는 생성 역할을 하는 팩토리 클래스의 공통 인터페이스를 정의함

### 의존성 주입

- 사용과 제작을 분리하는 강력한 메커니즘 하나가 의존성 주입이다.
- 제어 역전 기법을 의존성 관리에 적용한 매커니즘
- 새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임 원칙을 지키게 된다.
- 의존성 관리 맥락에서 객체는 의존성 자체를 인스턴스로 만드는 책임은 지지 않는다.
- 대신에 이런 책임을 다른 전담 매커니즘에 넘겨야만 한다. 그렇게 제어를 역전시킨다.
- 초기 설정은 시스템 전체에서 필요하므로 대개 ‘책임질' 매커니즘으로 ‘main’ 루틴이나 특수 컨테이너를 사용한다.

- 의존성 주입에서 클래스는 스스로 의존성을 해결하지 않는다. 완전히 수동적이다.
- 대신에 의존성을 주입하는 방법으로 설정자 메서드나 생성자 인수를 제공한다.

### 확장

- ‘처음부터 올바르게' 시스템을 만들 수 있다는 믿음은 미신이다.
- 대신에 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다.
- 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다.
- 이것이 반복적이고 점진적인 애자일 방식의 핵심이다.
- 테스트 주도 개발, 리팩터링, 깨끗한 코드는 코드수준에서 시스템을 조정하고 확장하기 쉽게 만든다.

- 하지만 시스템수준에서는?
- 소프트웨어 시스템은 물리적인 시스템과 다르다.
- 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.
- 소프트웨어 시스템은 ‘수명이 짧다'는 본질로 인해 아키텍처의 점진적인 발전이 가능하다.

### 횡단 관심사

- 영속성과 같은 관심사는 애플리케이션의 자연스러운 객체 경계를 넘나드는 경향이 있다.
- 모든 객체가 전반적으로 동일한 방식을 이용하게 만들어야 한다.
- 현실적으로 영속성 방식을 구현한 코드가 온갖 객체로 흩어진다. 여기서 횡단 관심사라는 용어가 나온다.
- AOP는 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론이다.
- AOP에서 관점이라는 모듈 구성 개념은 “특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 잇게 바꿔야 한다"라고 명시한다.
- 명시는 간결한 선언이나 프로그래밍 매커니즘으로 수행한다.

### 테스트 주도 시스템 아키텍처 구축

- 관점으로 관심사를 분리하는 방식은 그 위력이 막강하다.
- 코드 수준에서 아키텍처 관심사를 분리할 수 있다면, 진정한 테스트 주도 아키텍처 구축이 가능해진다.

- 건축가는 BDUF(구현을 시작하기 전에 앞으로 벌어질 모든 사항을 설계하는 기법) 방식을 취한다.
- 물리적 구조는 일단 짓기 시작하면 극적인 변경이 불가능한 탓이다.
- 소프트웨어 역시 나름대로 형체가 있지만, 소프트웨어 구조가 관점을 효과적으로 분리한다면, 극적인 변화가 경제적으로 가능하다.
- 다시말해, 아주 단순하면서도 멋지게 분리된 아키텍처로 소프트웨어 프로젝트를 진행해 결과물을 재빨리 출시한 후, 기반 구조를 추가하며 조금씩 확장해 나가도 괜찮다는 말이다.

### 의사결정을 최적화하라

- 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해진다.
- 도시든 소프트웨어 프로젝트든, 아주 큰 시스템에서는 한 사람이 모든 결정을 내리기 어렵다.
- 가장 적합한 사람에게 책임을 맡기면 좋다.

### 명백한 가치가 있을 때 표준을 현명하게 사용하라.

- 나는 업계에서 여러 형태로 아주 과장되게 포장된 표준에 집착하는 바람에 고객 가치가 뒷전으로 밀려난 사례를 많이 봤다.
- 표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉽고, 컴포넌트를 엮기 쉽다.
- 하지만 때로는 표준을 만드는 시간이 너무 오래 걸려 업계가 기다리지 못한다.
- 어떤 표준은 워래 표준을 제정한 목적을 잊어버리기도 한다.

### 결론

- 시스템 역시 깨끗해야 한다.
- 깨끗하지 못한 아키텍처는 도메인 논리를 흐리며 기민성을 떨어뜨린다.
- 도메인 논리가 흐려지면 제품품질이 떨어진다.
- 버그가 숨어들기 쉬워지고, 스토리를 구현하기 어려워지는 탓이다.
- 기민성이 떨어지면 생산성이 낮아져 TDD가 제공하는 장점이 사라진다.
- 시스템을 설계하든 개별 모듈을 설계하든, 실제로 돌아가는 가장 단순한 수단을 사용해야 한다는 사실을 명심하자.

---

의존성 주입, 추상 팩토리, aop 사용하는 이유는 이해함. 다른 얘기들은 아직 별로 와닿진 않는다.
